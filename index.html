<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stormy Rock Paper Scissors Sandbox</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #87ceeb;
        height: 100%;
    }
    canvas {
        display: block;
        touch-action: none;
    }
    #controls {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.5);
        padding: 8px 14px;
        border-radius: 14px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
    }
    #controls label {
        color: white;
        font-size: 14px;
    }
    #controls input {
        max-width: 80px;
    }
    #watermark {
        position: fixed;
        bottom: 5px;
        right: 8px;
        color: white;
        font-size: 12px;
        opacity: 0.7;
        font-family: monospace;
    }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="controls">
    <label>Speed <input type="range" id="speed" min="0.5" max="5" step="0.5" value="2"></label>
    <label>Entities <input type="number" id="count" min="3" max="50" value="12"></label>
    <button id="reset">Reset</button>
</div>
<div id="watermark">coded by timelord</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

const speedSlider = document.getElementById("speed");
const countInput = document.getElementById("count");
const resetBtn = document.getElementById("reset");

const TYPES = ["rock", "paper", "scissors"];
const COLORS = {
    rock: "#a0522d",
    paper: "#fffacd",
    scissors: "#c0c0c0"
};
const PARTICLES = {
    rock: "#deb887",
    paper: "#f0e68c",
    scissors: "#ffd700"
};

let entities = [];
let speedFactor = parseFloat(speedSlider.value);
let rainDrops = [];
let clouds = [];
let hills = [];
let lightningFlash = 0;

function random(min, max) { return Math.random() * (max - min) + min; }

// Create background hills
function createHills() {
    hills = [];
    for (let i = 0; i < 3; i++) {
        hills.push({
            y: height - 80 - i * 30,
            color: `hsl(${120 + i*20}, 40%, ${30+i*10}%)`,
            speed: 0.2 + i*0.1
        });
    }
}

// Create clouds
function createClouds() {
    clouds = [];
    for (let i = 0; i < 6; i++) {
        clouds.push({
            x: random(0, width),
            y: random(20, height/3),
            size: random(50, 120),
            speed: random(0.1, 0.3)
        });
    }
}

// Create rain
function createRain() {
    rainDrops = [];
    for (let i = 0; i < 200; i++) {
        rainDrops.push({
            x: random(0, width),
            y: random(0, height),
            length: random(10, 20),
            speed: random(4, 8)
        });
    }
}

class Entity {
    constructor(type) {
        this.type = type;
        this.x = random(50, width-50);
        this.y = random(50, height-150);
        this.vx = random(-2, 2);
        this.vy = random(-2, 2);
        this.size = 30;
        this.scale = 1;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.fillStyle = COLORS[this.type];
        ctx.beginPath();
        if (this.type === "rock") {
            ctx.ellipse(0, 0, this.size, this.size*0.8, 0, 0, Math.PI*2);
        } else if (this.type === "paper") {
            ctx.rect(-this.size, -this.size*1.2, this.size*2, this.size*2.4);
        } else if (this.type === "scissors") {
            ctx.moveTo(-this.size, -this.size);
            ctx.lineTo(this.size, this.size);
            ctx.moveTo(this.size, -this.size);
            ctx.lineTo(-this.size, this.size);
        }
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
    move() {
        this.x += this.vx * speedFactor;
        this.y += this.vy * speedFactor;
        if (this.x < this.size || this.x > width - this.size) this.vx *= -1;
        if (this.y < this.size || this.y > height - this.size - 50) this.vy *= -1;
    }
}

function spawnEntities(n) {
    entities = [];
    for (let i = 0; i < n; i++) {
        entities.push(new Entity(TYPES[Math.floor(Math.random()*3)]));
    }
}

function collide(e1, e2) {
    let dx = e1.x - e2.x;
    let dy = e1.y - e2.y;
    let dist = Math.hypot(dx, dy);
    if (dist < e1.size + e2.size) {
        if (beats(e1.type, e2.type)) {
            e2.type = e1.type;
            squash(e1);
        } else if (beats(e2.type, e1.type)) {
            e1.type = e2.type;
            squash(e2);
        }
    }
}

function beats(a, b) {
    return (a === "rock" && b === "scissors") ||
           (a === "scissors" && b === "paper") ||
           (a === "paper" && b === "rock");
}

function squash(entity) {
    entity.scale = 1.5;
    setTimeout(() => { entity.scale = 1; }, 150);
}

function drawBackground() {
    ctx.fillStyle = "#87ceeb";
    ctx.fillRect(0, 0, width, height);

    // Hills
    for (let h of hills) {
        ctx.fillStyle = h.color;
        ctx.beginPath();
        ctx.moveTo(0, h.y);
        for (let x = 0; x <= width; x += 20) {
            ctx.lineTo(x, h.y - Math.sin(x/50)*20);
        }
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
    }

    // Clouds
    ctx.fillStyle = "#fff";
    for (let c of clouds) {
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, c.size, c.size/2, 0, 0, Math.PI*2);
        ctx.fill();
    }
}

function drawRain() {
    ctx.strokeStyle = "rgba(255,255,255,0.7)";
    ctx.lineWidth = 2;
    for (let r of rainDrops) {
        ctx.beginPath();
        ctx.moveTo(r.x, r.y);
        ctx.lineTo(r.x + 3, r.y + r.length);
        ctx.stroke();
    }
}

function updateRain() {
    for (let r of rainDrops) {
        r.y += r.speed;
        r.x += 1;
        if (r.y > height) {
            r.y = -10;
            r.x = random(0, width);
        }
    }
}

function updateClouds() {
    for (let c of clouds) {
        c.x += c.speed;
        if (c.x - c.size > width) c.x = -c.size;
    }
}

function maybeLightning() {
    if (Math.random() < 0.005) {
        lightningFlash = 10;
    }
    if (lightningFlash > 0) {
        ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
        ctx.fillRect(0, 0, width, height);
        lightningFlash--;
    }
}

function animate() {
    ctx.clearRect(0, 0, width, height);
    drawBackground();
    updateClouds();
    drawRain();
    updateRain();
    maybeLightning();

    for (let i = 0; i < entities.length; i++) {
        for (let j = i+1; j < entities.length; j++) {
            collide(entities[i], entities[j]);
        }
    }

    for (let e of entities) {
        e.move();
        e.draw();
    }

    requestAnimationFrame(animate);
}

speedSlider.addEventListener("input", () => {
    speedFactor = parseFloat(speedSlider.value);
});
resetBtn.addEventListener("click", () => {
    spawnEntities(parseInt(countInput.value));
});

// Mobile resize handling
window.addEventListener("resize", () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    createHills();
    createClouds();
    createRain();
});

canvas.addEventListener("touchstart", (e) => {
    let touch = e.touches[0];
    entities.push(new Entity(TYPES[Math.floor(Math.random()*3)]));
    entities[entities.length-1].x = touch.clientX;
    entities[entities.length-1].y = touch.clientY;
});

// Init
createHills();
createClouds();
createRain();
spawnEntities(parseInt(countInput.value));
animate();
</script>
</body>
</html>
